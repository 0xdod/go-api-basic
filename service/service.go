// Package service orchestrates components between handlers and other
// packages (datastore, gateway, domain, etc.)
package service

import (
	"context"
	"time"

	"github.com/gilcrest/go-api-basic/domain/app"
	"github.com/gilcrest/go-api-basic/domain/user"
	"github.com/google/uuid"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgx/v4"
	"github.com/jackc/pgx/v4/pgxpool"

	"github.com/gilcrest/go-api-basic/domain/audit"
)

// Datastorer is an interface for working with the Database
type Datastorer interface {
	// Pool returns *pgxpool.Pool
	Pool() *pgxpool.Pool
	// BeginTx starts a pgx.Tx using the input context
	BeginTx(ctx context.Context) (pgx.Tx, error)
	// RollbackTx rolls back the input pgx.Tx
	RollbackTx(ctx context.Context, tx pgx.Tx, err error) error
	// CommitTx commits the Tx
	CommitTx(ctx context.Context, tx pgx.Tx) error
}

// DBTX interface mirrors the interface generated by https://github.com/kyleconroy/sqlc
// to allow passing a Pool or a Tx
type DBTX interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
}

// CryptoRandomGenerator is the interface that generates random data
type CryptoRandomGenerator interface {
	RandomBytes(n int) ([]byte, error)
	RandomString(n int) (string, error)
}

// auditResponse is to be embedded into other structs for the purpose
// of displaying audit information.
type auditResponse struct {
	AppExternalID string `json:"app_external_id"`
	AppName       string `json:"app_name"`
	Username      string `json:"username"`
	AuditTime     string `json:"audit_time"`
}

func newAuditResponse(adt audit.Audit) auditResponse {
	return auditResponse{
		AppExternalID: adt.App.ExternalID.String(),
		AppName:       adt.App.Name,
		Username:      adt.User.Username,
		AuditTime:     adt.Moment.Format(time.RFC3339),
	}
}

func newAudit(ctx context.Context, dbtx DBTX, appID uuid.UUID, userID uuid.NullUUID, moment time.Time) (audit.Audit, error) {
	var (
		a   app.App
		u   user.User
		err error
	)

	a, _, err = findAppByID(ctx, dbtx, appID, false)
	if err != nil {
		return audit.Audit{}, err
	}

	if userID.Valid {
		u, err = findUserByID(ctx, dbtx, userID.UUID)
		if err != nil {
			return audit.Audit{}, err
		}
	}

	return audit.Audit{
		App:    a,
		User:   u,
		Moment: moment,
	}, nil
}
