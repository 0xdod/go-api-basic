// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package main

import (
	"context"
	"database/sql"
	"github.com/gilcrest/go-api-basic/app"
	"github.com/gilcrest/go-api-basic/datastore"
	"github.com/gilcrest/go-api-basic/handler"
	"github.com/google/wire"
	"github.com/gorilla/mux"
	"github.com/rs/zerolog"
	"go.opencensus.io/trace"
	"gocloud.dev/server"
	"gocloud.dev/server/driver"
	"gocloud.dev/server/health"
	"gocloud.dev/server/health/sqlhealth"
	"gocloud.dev/server/requestlog"
	"net/http"
	"time"
)

// Injectors from wireInject.go:

func setupLocal(ctx context.Context, flags *cliFlags) (*server.Server, func(), error) {
	envName := newEnvName(flags)
	dsName := newDSName(flags)
	datastoreDatastore, err := datastore.NewDatastore(dsName)
	if err != nil {
		return nil, nil, err
	}
	level := newLogLevel(flags)
	logger := newLogger(level)
	application := app.NewApplication(envName, datastoreDatastore, logger)
	appHandler := handler.NewAppHandler(application)
	router := newRouter(appHandler)
	mainRequestLogger := newRequestLogger(logger)
	exporter := _wireExporterValue
	sampler := trace.AlwaysSample()
	defaultDriver := server.NewDefaultDriver()
	options := &server.Options{
		RequestLogger:         mainRequestLogger,
		TraceExporter:         exporter,
		DefaultSamplingPolicy: sampler,
		Driver:                defaultDriver,
	}
	serverServer := server.New(router, options)
	return serverServer, func() {
	}, nil
}

var (
	_wireExporterValue = trace.Exporter(nil)
)

// wireInject.go:

// applicationSet is the Wire provider set for the Guestbook application that
// does not depend on the underlying platform.
var applicationSet = wire.NewSet(app.NewApplication, newRouter, wire.Bind(new(http.Handler), new(*mux.Router)), handler.NewAppHandler, newLogger,
	newLogLevel, datastore.NewDatastore, newDSName,
	newEnvName,
)

// goCloudServerSet
var goCloudServerSet = wire.NewSet(trace.AlwaysSample, server.New, wire.Struct(new(server.Options), "RequestLogger", "TraceExporter", "DefaultSamplingPolicy", "Driver"), server.NewDefaultDriver, wire.Bind(new(driver.Server), new(*server.DefaultDriver)), wire.Bind(new(requestlog.Logger), new(*requestLogger)), newRequestLogger)

type requestLogger struct {
	log zerolog.Logger
}

func (rl requestLogger) Log(e *requestlog.Entry) {
	rl.log.Log().
		Str("received_time", e.ReceivedTime.Format(time.RFC1123)).
		Str("request_method", e.RequestMethod).
		Str("request_url", e.RequestURL).
		Int64("request_header_size", e.RequestHeaderSize).
		Int64("request_body_size", e.RequestBodySize).
		Str("user_agent", e.UserAgent).
		Str("referer", e.Referer).
		Str("protocol", e.Proto).
		Str("remote_ip", e.RemoteIP).
		Str("server_ip", e.ServerIP).
		Int("status", e.Status).
		Int64("response_header_size", e.ResponseHeaderSize).
		Int64("response_body_size", e.ResponseBodySize).
		Int64("latency in millis", e.Latency.Milliseconds()).
		Str("trace_id", e.TraceID.String()).
		Str("span_id", e.SpanID.String()).
		Msg("request received")
}

func newRequestLogger(l zerolog.Logger) *requestLogger {
	return &requestLogger{log: l}
}

// appHealthChecks returns a health check for the database. This will signal
// to Kubernetes or other orchestrators that the server should not receive
// traffic until the server is able to connect to its database.
func appHealthChecks(db *sql.DB) ([]health.Checker, func()) {
	dbCheck := sqlhealth.New(db)
	list := []health.Checker{dbCheck}
	return list, func() {
		dbCheck.Stop()
	}
}
