// Code generated by Wire. DO NOT EDIT.

//go:generate wire
//+build !wireinject

package main

import (
	"context"
	"database/sql"
	"github.com/gilcrest/go-api-basic/app"
	"github.com/gilcrest/go-api-basic/datastore"
	"github.com/gilcrest/go-api-basic/handler"
	"github.com/google/wire"
	"github.com/gorilla/mux"
	"github.com/rs/zerolog"
	"go.opencensus.io/trace"
	"gocloud.dev/server"
	"gocloud.dev/server/driver"
	"gocloud.dev/server/health"
	"gocloud.dev/server/health/sqlhealth"
	"gocloud.dev/server/requestlog"
	"net/http"
	"time"
)

// Injectors from inject_main.go:

func setupApp(ctx context.Context, envName app.EnvName, dsName datastore.DSName, loglvl zerolog.Level) (*server.Server, func(), error) {
	db, cleanup, err := datastore.NewDB(dsName)
	if err != nil {
		return nil, nil, err
	}
	datastoreDatastore, err := datastore.NewDatastore(dsName, db)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	logger := newLogger(loglvl)
	application := app.NewApplication(envName, datastoreDatastore, logger)
	appHandler := handler.NewAppHandler(application)
	router := newRouter(appHandler)
	mainRequestLogger := newRequestLogger(logger)
	v, cleanup2 := appHealthChecks(dsName, db)
	exporter := _wireExporterValue
	sampler := trace.AlwaysSample()
	defaultDriver := server.NewDefaultDriver()
	options := &server.Options{
		RequestLogger:         mainRequestLogger,
		HealthChecks:          v,
		TraceExporter:         exporter,
		DefaultSamplingPolicy: sampler,
		Driver:                defaultDriver,
	}
	serverServer := server.New(router, options)
	return serverServer, func() {
		cleanup2()
		cleanup()
	}, nil
}

var (
	_wireExporterValue = trace.Exporter(nil)
)

func setupAppwMock(ctx context.Context, envName app.EnvName, dsName datastore.DSName, loglvl zerolog.Level) (*server.Server, func(), error) {
	db := datastore.NewMockDB(dsName)
	datastoreDatastore, err := datastore.NewDatastore(dsName, db)
	if err != nil {
		return nil, nil, err
	}
	logger := newLogger(loglvl)
	application := app.NewApplication(envName, datastoreDatastore, logger)
	appHandler := handler.NewAppHandler(application)
	router := newRouter(appHandler)
	mainRequestLogger := newRequestLogger(logger)
	v, cleanup := appHealthChecks(dsName, db)
	exporter := _wireTraceExporterValue
	sampler := trace.AlwaysSample()
	defaultDriver := server.NewDefaultDriver()
	options := &server.Options{
		RequestLogger:         mainRequestLogger,
		HealthChecks:          v,
		TraceExporter:         exporter,
		DefaultSamplingPolicy: sampler,
		Driver:                defaultDriver,
	}
	serverServer := server.New(router, options)
	return serverServer, func() {
		cleanup()
	}, nil
}

var (
	_wireTraceExporterValue = trace.Exporter(nil)
)

// inject_main.go:

// applicationSet is the Wire provider set for the Guestbook application that
// does not depend on the underlying platform.
var applicationSet = wire.NewSet(app.NewApplication, appHealthChecks,
	newRouter, wire.Bind(new(http.Handler), new(*mux.Router)), handler.NewAppHandler, newLogger, datastore.NewDatastore,
)

// goCloudServerSet
var goCloudServerSet = wire.NewSet(trace.AlwaysSample, server.New, wire.Struct(new(server.Options), "RequestLogger", "HealthChecks", "TraceExporter", "DefaultSamplingPolicy", "Driver"), server.NewDefaultDriver, wire.Bind(new(driver.Server), new(*server.DefaultDriver)), wire.Bind(new(requestlog.Logger), new(*requestLogger)), newRequestLogger)

type requestLogger struct {
	log zerolog.Logger
}

func (rl requestLogger) Log(e *requestlog.Entry) {
	rl.log.Log().
		Str("received_time", e.ReceivedTime.Format(time.RFC1123)).
		Str("request_method", e.RequestMethod).
		Str("request_url", e.RequestURL).
		Int64("request_header_size", e.RequestHeaderSize).
		Int64("request_body_size", e.RequestBodySize).
		Str("user_agent", e.UserAgent).
		Str("referer", e.Referer).
		Str("protocol", e.Proto).
		Str("remote_ip", e.RemoteIP).
		Str("server_ip", e.ServerIP).
		Int("status", e.Status).
		Int64("response_header_size", e.ResponseHeaderSize).
		Int64("response_body_size", e.ResponseBodySize).
		Int64("latency in millis", e.Latency.Milliseconds()).
		Str("trace_id", e.TraceID.String()).
		Str("span_id", e.SpanID.String()).
		Msg("request received")
}

func newRequestLogger(l zerolog.Logger) *requestLogger {
	return &requestLogger{log: l}
}

// appHealthChecks returns a health check for the database. This will signal
// to Kubernetes or other orchestrators that the server should not receive
// traffic until the server is able to connect to its database.
func appHealthChecks(n datastore.DSName, db *sql.DB) ([]health.Checker, func()) {
	if n != datastore.MockDatastore {
		dbCheck := sqlhealth.New(db)
		list := []health.Checker{dbCheck}
		return list, func() {
			dbCheck.Stop()
		}
	}
	mockCheck := new(mockChecker)
	list := []health.Checker{mockCheck}
	return list, func() {}
}

// mockChecker mocks the health of a SQL database.
type mockChecker struct {
	healthy bool
}

// mockChecker returns a nil error, signifying the mock db is up
func (c *mockChecker) CheckHealth() error {
	return nil
}
